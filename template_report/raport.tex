\documentclass[a4paper,11pt]{custom}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[left=2.5cm,right=2.5cm]{geometry}
\usepackage[official]{eurosym}

%
%--------------------   start of the 'preamble'
%
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{wrapfig}
\usepackage{xspace}
\usepackage{listingsutf8}
\usepackage{relsize}
\usepackage{indentfirst}

%\usepackage{makeidx}
%\usepackage{multirow}
%\usepackage{textcomp}

% Font selection
%\usepackage{amssymb}
%\usepackage{sectsty}
%
%%    homebrew commands -- to save typing
\newcommand\etc{\textsl{etc}}
\newcommand\eg{\textsl{eg.}\ }
\newcommand\etal{\textsl{et al.}}
\newcommand\Quote[1]{\lq\textsl{#1}\rq}
\newcommand\fr[2]{{\textstyle\frac{#1}{#2}}}
\newcommand\miktex{\textsl{MikTeX}}
\newcommand\comp{\textsl{The Companion}}
\newcommand\nss{\textsl{Not so Short}}
%
%---------------------   end of the 'preamble'
%
\newcommand{\smu}{\textsc{Smart Me Up}}

\newcommand{\rtp}{\textbf{rtp}\xspace}
\newcommand{\rtcp}{\textbf{rtcp}\xspace}
\newcommand{\rtsp}{\textbf{rtsp}\xspace}

\newcommand{\vlc}{\textbf{vlc}\xspace}
\newcommand{\avconv}{\textbf{avconv}\xspace}
\newcommand{\ffmpeg}{\textbf{ffmpeg}\xspace}
\newcommand{\gstreamer}{\textbf{gstreamer}\xspace}
\newcommand{\Gstreamer}{\textbf{Gstreamer}\xspace}
\newcommand{\curl}{\textbf{curl}\xspace}
\newcommand{\boost}{\textbf{boost}\xspace}
\newcommand{\happyhttp}{\textbf{HappyHTTP}\xspace}
\newcommand{\libcurl}{\textbf{libcurl}\xspace}

\newcommand{\mjpeg}{\textbf{mjpeg}\xspace}
\newcommand{\jpeg}{\textbf{jpeg}\xspace}
\newcommand{\vpx}{\textbf{vp8}\xspace}
\newcommand{\mpeg}{\textbf{h264}\xspace}

\newcommand{\cmake}{\textbf{cmake}\xspace}
\newcommand{\jni}{\textbf{jni}\xspace}
\newcommand{\fpm}{\textbf{fpm}\xspace}
\newcommand{\bash}{\textbf{bash}\xspace}
\newcommand{\python}{\textbf{python}\xspace}

\newcommand{\command}[1]{\textbf{#1}\xspace}

\newcommand{\rpi}{\textbf{raspberry pi}\xspace}
\newcommand{\bbb}{\textbf{beaglebone black}\xspace}

\newcommand{\linux}{\textbf{Linux}\xspace}
\newcommand{\win}{\textbf{Windows}\xspace}
\newcommand{\mac}{\textbf{Mac}\xspace}
\newcommand{\android}{\textbf{Android}\xspace}
\newcommand{\ios}{\textbf{iOS}\xspace}

\newcommand{\claude}{\textit{Claude}\xspace}

\newcommand{\nth}[1]{#1$^{\text{\tiny th}\xspace}$}
\newcommand{\second}{2$^{\text{\tiny nd}\xspace}$}

%C plus plus
\newcommand{\cpp}{%
  C\kern-.1667em\raise.30ex\hbox{\smaller{++}\xspace}%
  \spacefactor1000%
}
\newcommand{\clang}{%
  C\kern-.1667em%
  \xspace%
}
\newcommand{\json}{\textbf{json}\xspace}

\setlength{\parskip}{1em}

\begin{document}
%-----------------------------------------------------------

% \section La page de couverture du rapport (dont vous trouverez un modèle sur 
% l¿intranet) doit comporter obligatoirement les informations suivantes:

% \item le nom et prénom du stagiaire
% \item l'indication "stage de deuxième année"
% \item le nom de l¿enseignant scientif i que membre du jury
% \item le nom et l'adresse de la structure d¿accueil
% \item les dates de début et de fi n du stage, et sa durée
% \item le sujet du stage

\title{
  Live video streaming
}
\author{
  Robin Moussu 2A SLE
  \thanks{
  \begin{tabular}{c}
    \textit{Intership of 2$^{nd}$ year as}\\
    \textit{engineer assistant}\\
    \vspace{2em}\\
    \begin{tabular}{rcl}
      15 june &--& 15 september\\
      \multicolumn{3}{c}{3 months}\\
      \\
      tutor &--& Olivier Kilh \\
      supervised by &--& Steven Durand \\
      ensimag tutor &--& Roland Groz\\
      \\
    \end{tabular}
    \vspace{2em}\\
    \smu\\
    4 chemin des prés\\
    Meylan\\
  \end{tabular}
  }
}
\date{
  September, 2015
}
\maketitle

%-----------------------------------------------------------

~
\thispagestyle{empty}

\headerdecoration[-.5cm]{PaleTurquoise}%
\headerleftcontent{\headerlefttext}%
\headerrightcontent{\headerrighttext}%
\myfootrulebegin[-.5cm]
\myfootruleend

~

\clearpage

\pagenumbering{arabic}

~

\vspace{\fill}
\begin{flushright}
\begin{minipage}[b]{7cm}
I want to thanks warmly M. Steven Durand (CTO) and M. Loïc Lecerf (CEO) for
guiding me during my intership, together with M. Olivier Kilh my tutor.

\vspace{0.5em}

My thanks also goes to all the employes and interns of \smu, especialy Maude
Premillieu and Gabriel Mattos Langeloh. It was realy a pleasant experience to
work with them.
\end{minipage}
\end{flushright}
\vspace{\fill}
\vspace{\fill}


\newpage
~
\newpage

%-----------------------------------------------------------
%\chapterimage{nature-clouds-hdr-phenomenon.jpg}
%\tableofcontents
%-----------------------------------------------------------
%\chapterimage{binary.jpg}
%\include{chap1}
%\chapterimage{Raspberry_Pi_2.jpg}
%\include{chap2}
%\chapterimage{webcams.jpg}
%include{chap3}
%\chapterimage{Spider_web_necklace_with_pearls_of_dew.jpg}
%\include{chap4}
%-----------------------------------------------------------
%\chapterimage{Pink_flowers.jpg} % Table of contents heading image
%\addcontentsline{toc}{chapter}{\numberline{}Bibliography}
%\include{biblio}
%-----------------------------------------------------------
%\appendix
%\include{app1}
%\include{app2}
%\include{app4}
%\include{app3}
%\include{app5}
%-----------------------------------------------------------


% Le rapport doit être synthétique et ne pourra donc pas porter sur tout ce
% que vous avez fait. A titre indicatif, il doit comporter une quinzaine de pages
% (de ces 15 pages, sont exclues la page de garde, la table des matières, la table des
% f i gures, ... Il est possible d¿ajouter des annexes).

% Un rapport scientif i que n¿est pas un récit chronologique du déroulement
% du stage. Il nécessite de prendre de la distance, de recenser toute l¿information
% utile d¿un travail de plusieurs mois, la hiérarchiser, la fi ltrer et la restructurer en
% quelques pages. Le discours indirect est de rigueur (sauf pour insister sur la
% contribution de l¿auteur) et les formulations doivent être précises et exactes.
% Outre votre capacité à présenter clairement la problématique, l¿existant et la
% méthodologie mise en ¿uvre, votre contribution personnelle doit apparaître
% sans ambiguïté. 

% Le squelette suivant est donné à titre indicatif et peut être adapté selon la
% nature du stage. Ces dif f érents points restent toutefois ceux attendus par le jury pour
% évaluer votre travail:

\chapterimage{nature-clouds-hdr-phenomenon.jpg}
\chapter{Introduction}
%% Introduire la problématique, les objectifs et l¿articulation du pré-rapport (2¿3
%% paragraphes)

My internship have been done in \smu, a start-up specialized in facial
recognition, from June \nth{15} to September \nth{15}. My tutor was Olivier
Kilh, a researcher in facial recognition. During my internship, I had many
contact why Steven Durand, the CTO, and Loic Lecerf, the CEO. I have worked whis
Gabriel Mattos Langeloh and Maude Premillieu, two other interns.

\smu{} is a start-up specialized in video recognition, especialy facial
recognition. His employees have developped a library that is able to make
real-time facial analisys. My goal during my internship was to create a
software. This one will be installed on \smu's client hardware (\linux, \win{}
or \android), then it will grab a video, and send the stream to \smu's server.
Gabriel has developped the server side of that project, and Maud the web
interface were the client can manage their subscriptions.

First I will present \smu{} and its employees. Then I will introduce the goal of
my intership, and the choises I have made. Next, I will describe the
methodology I have used during my intership. Afterward I will present the
results of my work and finnaly conclude.

\vspace{\fill}

\begin{center}
\textsc{\textsc{Key points}}
\end{center}

\begin{multicols}{2}
\begin{itemize}
\item \textbf{video capture}
\item \textbf{video compression}
\item \textbf{stream protocols (rtp, rtcp)}
\item \textbf{\cpp}
\item \textbf{real time}
\item \textbf{cross-compilation}
\end{itemize}
\end{multicols}

\newpage

\chapterimage{blanc.jpg}
\headerdecoration[-.5cm]{PaleTurquoise}%
\headerleftcontent{\headerlefttext}%
\headerrightcontent{\headerrighttext}%

\tableofcontents

\clearpage

\chapterimage{logo_smu.jpg}
\chapter{Presentation}
%% Présenter les éléments du contexte utile à la compréhension du rapport 
%% (entreprise, service, mission, ¿). Le «copier/coller» des sites web des 
%% entreprises est à proscrire ! (2 pages maximum) 

%\begin{figure}[h!]
  %\centering
  %\includegraphics[width=4cm]{smartmeup.jpg}
  %\label{fig:smartmeup}
  %\caption{\smu's logo}.
%\end{figure}

\section{The company}

\smu{}\footnote{http://www.smartmeup.org/} is a start up from Meylan whitch has create a library for facial
analysis. That solution is usable as a base that can be embeded is any device,
like drone, robots, interactives advertissements,…

\smu{} was found in February 2012 by Loïc Lecerf. He has a PhD in artificial
intelligence. The initial founding for his start-up came from the selling of
a website he had previously created.

The firsts client of \smu{} are Netatmo (in domotic solution) and Photomaton (to
ensure conformity of official photos). After finding thoses customers, three new
members has been hired: Steven Durand (polytecthnicien), Olivier Kihl and John
Ruz Hernandez (doctors in artificial inteligence and image recognition). A new
office has been create in Paris. The revenue of \smu{} in 2014 was 225'000\euro.

\begin{wrapfigure}[8]{r}{5cm}
  \centering
  \includegraphics[width=4cm]{french-tech.jpg}
  \label{fig:frenchtech}
  \caption{French Tech's logo}.
\end{wrapfigure}

In January 2015, \smu{} has participate in the CES (Consumer Electronics Show) in
Las Vegas. That event has increase it popularity, and new clients have been
found, including SNCF. \smu{} was as well present at the \textbf{French
Tech}\footnote{http://www.lafrenchtech.com/la-french-tech}
(an organization that promote the french start-up). Nowadays, \smu{} want to
make a fundrasing of 1 to 2 millions euros.

\section{The employees}

The organization chart is presented on the figure~\ref{fig:organigramme}.

\smu is a start-up of seven employees. Loïc Lecerf is the PDG and founder,
Matthieu Marquenet is the commercial director, and Jessica Lecerf is the
administrative director. For R\&D, the CTO is Steven Durand, and three
reserchers work under his orders: Oliver Kihl, Johf Ruiz Hernandez and
Enguerrand Quilliard. As soon as they will optain their foundraising, \smu{}
will hire new permanents.

During this summer, 7 interns has worked in \smu. Amélie Fondevilla, Adrien
Saumureau, Baptiste Josi, Sara Akaoka Bdassi and Sébastien Detroyat have work on
specific project. Gabriel Mattos Langeloh, Maude Premillieu and myself have work
on the \claude{} project.

\begin{figure}
  \centering
  \def\svgwidth{\columnwidth}
  \includegraphics[width=\textwidth]{organigramme.jpg}
  \label{fig:organigramme}
  \caption{organization chart of \smu}.
\end{figure}

\chapterimage{Raspberry_Pi_2.jpg}
\chapter{Goal of the internship}
%% Présenter de manière concise et intelligible par une personne non spécialiste du
%% domaine la problématique de votre stage et bien définir l¿existant :
%% (environ 5 pages)
%% le problème à résoudre
%% les objectifs précis attendus 
%% l¿état de l¿art des solutions existantes et des contraintes fi xées par 
%% l¿entreprise
%% votre solution motivée à partir de l¿analyse ci-dessus

\section{The \claude{} project}

I have worked together whith Gabriel and Maud, two others interns. Our goal was
to grab videos from customers' cameras, and to analyse them on \smu's server
inside the cloud. At \smu, we were the \claude{} department (it's a pun with
\textit{cloud computing} with a big french accent $:$-$)$ ). During our
intership, we worked in the same office, so we were able to exchange a lot.

Even if Oliver Kilh was my tutor, in facts it was Steven Durand and Loïc Lecerf
who suppervise me and the others interns of the \claude{} project.

My initial goal was to create a software that can stream a video from all type of
devices to the servers of \smu, where it will be analysed. To be more specific,
I had to support all type of webcam, on \linux, \win{} and \mac, smartphones
(\android, \ios), and ip cameras.

Gabriel goal was to create the softwares used on the server. Thoses sofwares
have to receive the video stream, and analyse them using the library developped
by \smu.

Maud has created the web interface. That website is the place where customer can
access to the results of their analysis and where they can administrate their
cameras (the clients have to pay a subscription for all their camera, and the
type of analysis they have chosen).

\section{Technologics choises}

Our goal (Gabriel, Maud and me) was to select the appropriate technology for
what we have to do. To be more specific:
\begin{itemize}
\item How to capture the images
\item How to encode them
\item How to send them to \smu{} server.
\end{itemize}

And furthurmore
\begin{itemize}
\item How to etablish connection between clients' software and \smu{} servers
\end{itemize}

Our first task was to learn how video are streamed in general. That part is
explained in details later (in the section~\ref{sec:technologies}). The objective
was to found witch protocols are used for grapping encode and send image. Of
course it was not in our plan to reivent the well, so we also add to choose a
library that implement thoses protocols.

Our second goal was to define how our sofware will exchange informations. Since
clients machine, and \smu{} server are all links to internet, we have choose to
use http request. We have defined all messages we can send, and their
structure. The methodology and the result is explained in the
section~\ref{sec:communication}.

\section{Plateforms}

As I said, my personnal goal was to write a software that could be run virtualy
everywhere. To be more specific, my initial targets were \linux{} (on PC, and
embedded devices like \rpi or \bbb), \win, \android, \mac{} and \ios. It was a
bit too ambitious, so the last two were dropped.

All employees in \smu work on ubuntu (a \linux{} distribution), so I have first
developped my solution for linux, keeping in mind that I will have to port it
after, so I never use plateform specific stuff. Then I port it to linux arm (I
have test it on \rpi{} and \bbb). After that, I try to create an \android{}
application, and finnaly for \win.

I was requested to write my software in \cpp. As a consequence of using native
language, my build system has to be able to create executable for all
plateforms. I have choose to use \cmake{} as build system, since \cmake{} was
already use in the company.

\section{Synthesis}

Since I have to support a very heterogeneous set a plateform, I had to be very
generic.

The main complicated part was to make tradeoff between performance required for
video encoding and the available bandwith. To lower the required bandwith, we
can use a better compression algorithm, however better algorithm mean highter
compression time, so worst lattency, and higher cpu usage. On slow CPU hardware
(smartphones and embedded devices like \rpi{} and \bbb{}) it was a real
challenge to found the right algorithm.

The results of the analisys of our needs for the \claude{} project have lead to
the sofware organization presented on figure~\ref{fig:architecture}. That figure
is exclacted from the documentation Gabriel has wrote. To be more clear, what I
will later call \textit{http gateway} is the \textit{serveur HTTP}. The \textit{source} is anything
with a webcam (a pc, an embeded device, or a smartphone).

My contribution on the project was the source, and the specification of the
communications between HTTP gateway and streaming and analysis server. Gabriel
have worked on the video \& analisys server, and Maud on the rest (her intership
was longer).

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{architecture.jpg}
  \label{fig:architecture}
  \caption{presentation of the \claude{} project structure}.
\end{figure}

\chapterimage{webcams.jpg}
\chapter{Methodology and alternatives}
\label{sec:methodology}
%% Décrire votre méthodologie de travail pour la mise en ¿uvre de votre solution 

\section{Organisation}

During all my intership, I had two small meeting per week (called \textit{point
claude}) with Steven Durand and Loïc Lecerf. The others interns of the \claude{}
project (Maude and Gabriel) were also there. During thoses meeting, we presented
the work we had done since the last time, and then we decide what to do next.
Since none of the employees of \smu{} have look our code during our intership (as
least for the \claude{} project, it was their only way to know what we were
doing.

Our general methodology was to quicly have something that work somewhere, and
then improve it by small iteration to make it work everywhere in all conditions.
As a consequence, we first test something on our machine, then using multiple
machine in local network, and finaly on the cloud.


\section{Technologies used}
\label{sec:technologies}

The main challenge of that internship was to found the right technology to
achieve the goal that I have been entrusted.

\subsection{Network protocol}

Firstly, we (Gabriel and me) have worked together to find the appropriate
protocol for video streaming. We have conclude that \rtp{} is a good choise.
That was motivate because \rtp{} can be easily replaced by \rtsp{} that work in
a similar way, but with encryption. Furthurmore, it can be use in tandem with
\rtcp, witch carry informations on the stream (like framerate, lag, and others
usefull informations to analyse the quality of the stream).

Select the right protocole is of course not enough, and since we have planed to
support multiples plateform, we have search implementations that match this
requirement. \ffmpeg{} (and his fork \avconv), \vlc{} and \gstreamer{} where good
quandidates. \vlc{} was quicly avoided, because it has too much code that we do
not need. It was nevertheless usefull for testing purpose. In July, we have used
\ffmpeg/\avconv, but we finally found that \gstreamer{} as better performance
results.

\subsection{Video encoding}

Having the right network protocol is still not enough. We had to choose an
encoding that fit our needs. What we want is something fast to encode,
because the client program can run on small hardware, and because low latency
was unavoidable. The resulted stream has also to be lightweight, because we
could not assume that \smu's client will have a fast internet connection.

All our tests have been first made on LAN, so \mjpeg{} was a very good
quandidate. It's just a sequence of \jpeg{} images, so it is realy, realy fast
to encode it, even on small hardware. As a direct consequence, the delay was
excellant. However when we have made the firsts real tests using a server
somewhere on the cloud, we have discover that the amount of data needed for the
transmission was too hight. So we had to choose something else less eager in
bandwith. We have tested \mpeg{} and \vpx, and we have choosen the later.

\subsection{Communication between devices}
\label{sec:communication}

At this point we knew how to grab images, encode them, and send them to a
server. It's cool, but we need something to ask the permission the server. We
choose to simply use http request. \curl{} was a good initial choise, since it
is a very powerfull library. However, in the optique of minimizing dependances,
I finally use \happyhttp. The request are formating is \json.

The documentation can be found is the appendix~\ref{sec:documentation}

\section{Minimize the dependency}

One of my objective was to create a sofware whose source code is really
portable. For making that task easier, my tutor ask me to minimize the number of
dependencies, and their complexities.

\subsection{Prototyping}

When I was prototyping, I have used some python and shell scripts to work
faster. Since we cannot assume that thoses languages are installed on our client
machine, my tutor ask me to use native code (to be more specific \cpp). Binary
package are not transfereable across operating system and cpu, so I had to
generate binaries for all targets.

In July, I have wrote a software that did the work, but with too many
dependencies. I had used \boost{} for arguments and json parsing, and \curl{}
for http request. I have also used \gstreamer{} for video (grab image, compress
using \vpx{} and send using \rtp/\rtcp). Only the last was a requiered
dependency.

\subsection{Reducing complexicity}
\label{sec:complexicity}

Removing \boost{} and \curl{} was too complicated, so I re-write my software,
but much faster than the first time, since I already know what I want to do, and
how to do it.

To replace \boost{}, I have wrote a minimal \json{} parser (for the sub-part of
json used for the communication between the client and the http gateway).
To parse the arguments provided to the program, I have made a manual read of
the arguments on \verb+argv+. Of course my own code have less possibilities than
\boost{}, but it was less complex, and that was what I was asked for.

With the similar optique, I have replaced \libcurl{} by \happyhttp. That second
library is only one small source file, so it is easier to embed it. Furthurmore
the employees of \smu{} were already using it. With some take back, I think that
using \libcurl{} during the prototyping was a good idea. Indeed it had help me to
understand the errors easily when we (Gabriel and me) were creating the http
protocol between the client software and the http gateway.

Despite everything my main dependency was etheir \gstreamer{} or
\ffmpeg/\avconv. Since they are both as complex, it was not an arguments in
favor of one or another. At the end, \gstreamer{} (and it's own dependencies) is
the last remaining in my code, even if it is the most complicated.

\section{Solving problems}

During my intership, I have wasted some time because at some point I was stuck,
and I had not enough method to find the right solution in a short time. Making
pair-programming was a good idea, but we did not use it enough for my taste.

Sometime, when I was stuck, I left my desk, to help someone else, and when I
came back that person help me back. In general, that save us both a lot of time,
because, it help us to take a more global view on what we were doing. The key
point of that is that explaining to someone else our problem help us to
formalize it.

\section{Writing the documentation}

During my intership, I have contributed to the writing of to type of
documentation. The first is the documentation of the http protocol used for the
communication. This one have been wrote gradually. The second one is the source
code documentation. I have mainly wrote it at the end of my intership.
\textbf{Doxygen}\footnote{http://www.stack.nl/~dimitri/doxygen/} have been used.
It is a powerfull documentation processor, commonly used.

\chapterimage{technology-computer-chips-gigabyte.jpg}
\chapter{Results}

\section{Technologies used}

\subsection{Generality}

I have wrote a software in \cpp that grab image and send the stream via \rtp to
the server of \smu. The protocoles used have been described previously (on
part~\ref{sec:methodology}). In that section, I am going to describe the
implementation details.

\subsection{Build system}

I have developped a build system based on \cmake. It was choosen because it is
cross plateform (that was obviously required since I huve to support many
system), and powerfull enough to fit my need. Furthurmore \cmake is also used on
other projects in \smu.

Our initial goal was to have a cross-plateform build system. In that ideal
scenario, when I want to create a new release of my software, I can create all
the binaries from the same host. At the beggining of August, I had set up that
type of build system. Like this, from my ubuntu, I was able to build binaries
not only for x86\_64 \linux, but also for arm \linux.

However, when I have try to staticly link all the dependencies,
cross-compilation has become too complicated to maintain. In effect, \gstreamer
has a lot of dependances, including the \textbf{glib}. During the link process,
everything as previously build for the destination architecture, so in this
case, have to be previously cross-compiled. That took me too much time to
maintain, and as a consequence I have stopped to developpe it and I have come
back to a more simple build system.

In addittion to the \cmake files, I have also wrote a small \python script
to call \cmake more easyly. I have developped it when I was trying to make
cross compilation. So in one command, I build the whole program for all
architectures. After the drop of the cross-compilation, I used it just as an
helper.

The build process for \linux, on intel and arm device or for \win{} is quite
similar (except some fiew `\#ifdef`) thanks to \cmake. On \android{} however,
The main has to be written in java. So, I have used \jni{} to build my \cpp{}
codebase and linked it to java. Thus I can reutilize my work across all systems.

\subsection{Grab image and send video}

As I have explained, \gstreamer have been choosen. It have a lots of binding
(including \cpp), but I finnaly choose to use the \clang api, since it have the
best documentation. \Gstreamer is pretty easy to use when you have understood
some basics stuff. \Gstreamer use a textual representation of the acquisition
proccess, called a pipeline.

The listing~\ref{fig:exctractcppcode} describe the command used to describe the
\gstreamer pipeline. It grab a video using `autovideosrc`. Then it set some
attribute. After that the stream is encoding in \vpx with `vp8enc` and some
tuning for performance (`speed=1 thread=2`). And finally the stream is sent
using \rtp, and add \rtcp informations. This is an extract of the \cpp code
I have wrote. The easier way to test it, it to use the \bash command
\command{gst-launch} that used the same syntax.

\begin{figure}
\begin{lstlisting}
string cmd { "gstrtpbin name=rtpbin autovideosrc"
        " ! videorate"
        " ! videoscale"
        " ! ffmpegcolorspace"
        " ! video/x-raw-yuv,width=" + video_width + ",height=" + video_height +
        " ! vp8enc speed=1 threads=2"
        " ! rtpvp8pay"
        " ! rtpbin.send_rtp_sink_0 rtpbin.send_rtp_src_0"
        " ! udpsink host=" + video_url + " port=" + rtp_port +
             " rtpbin.send_rtcp_src_0 "
        " ! udpsink host=" + video_url + " port=" + rtcp_port +
             " sync=false async=false udpsrc port=" + local_rtcp_port + " "
        " ! rtpbin.recv_rtcp_sink_0"};
auto pipeline = gst_parse_launch( cmd.c_str(), &error );
\end{lstlisting}
\label{fig:exctractcppcode}
\caption{Exctract of \cpp code: gstreamer pipeline used for emission}.
\end{figure}

Before using \gstreamer, I have used \ffmpeg/\avconv. They work similary (a
\clang API, and a \bash command). However the syntax is not the same.

\subsection{Android}

Android sofware has to be in java. Since my work was done in \cpp, I have use
\jni, that allow me to call \cpp code from java. \jni use makefile, so I had to
adapt my build process in consequence. My \cpp code have to create a dynamic
library, and a small \cpp file make the glue between my code and the interface
(in java).

The interface used on mobile has been design by Maud. A screeshot is presented
on figure~\ref{fig:smumobile}.

\begin{figure}
\centering
\includegraphics[height=8cm]{smu_mobile.jpg}
\caption{Mobile interface}
\label{fig:smumobile}
\end{figure}

I have also use the \android{} sdk and ndk as well as the gstreamer sdk. Using
thoses software tools as allow me to easily start to port my software. However,
some differences in the usage of \gstreamer{} on \android{} have made the
developpement more difficult, and I had not enough time to finish it.

\subsection{Installer}

In July, I have created an installer for linux, using
\fpm{}\footnote{https://github.com/jordansissel/fpm}. It is a software that can
create \textbf{.deb} (debian/ubuntu package), \textbf{.rmp} (used on other
linux), \textbf{tar} package,… I was realy easy to do, and I will use it again
for another project if need be.

However, in August, the objective of my intership have change a bit, and at this
point, we had to create a demonstrator. Therefore my software has to be as easy
as possible to use, so removing the installation step was requiered. That was
taking part of the clean process I have explain before (section
\ref{sec:complexicity}).

\section{Conclusion}

To sum up, at the end of my intership, I have wrote a sofware that can compile
and run on multiple plateforms~: \linux{} (both intel and arm) and \win. A lots
of work have also be done for \android, but not everything have been finished.
My program is able to ask the htpp gateway the autorization to start the stream.
Then it grab images, compress them using \vpx{} encoding, and send them using a
\rtp{}/\rtcp{} stream. All that is done using a gstreamer backend. The program I
wrote still need more tuning to be faster, especially on embedded hardware.

%\chapterimage{Pink_flowers.jpg} % Table of contents heading image
\chapterimage{binary.jpg}
\chapter{Personnal conclusion}

To sum up, the keys points of my intership were:
\begin{multicols}{2}
\begin{itemize}
\item design a sofware architecture
\item define witch protocols will be used and how
\item create a robust build system
\item understand the link process
\item how to build for multiple target (\linux{} arm and intel, \win, \android)
\item try to have cross compilation
\end{itemize}
\end{multicols}

The part that motivate me the most was designing the communication protocol.
When designing a protocol, we have to take care of making it both expressive and
easy to parse/understand. I found that the result is pretty clean, and it was a
good experience to work with Gabriel and Maud under the direction of Steven
Durand and Loïc Lecerf.

The major amount of work was the build process and its fine details. Building
for one architecture is realy easy, however when we want to support many more
system, it become more complicated. \cmake{} was realy usefull to simplify that
task. What was too complicated for me was cross-compiling with many dependencies
at the same time, using static link. Despite everything, I have learned a lot of
that process.

To summurize, that intership was really instructive, and I feel that I have a
finer understanding of the \cpp{} build process.

\appendix

\chapterimage{blanc}
\chapter*{Appendix}

\chapter{Communication documentation}
\label{sec:documentation}
\input{md_source_source.tex}

\end{document}
